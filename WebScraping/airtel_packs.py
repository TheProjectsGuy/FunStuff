# Scrap plans for pre-paid recharge from Airtel's website
"""
    Because I'm too lazy to go through all plans. Just scrap them 
    using selenium, save them to an ODS spreadsheet, and analyze.
    Give me the cheapest plans (based on daily cost) with daily and
    fixed data renewals.
    
    Warning: Use at your own risk. Always confirm details from the
        official websites.
    
    Notes:
    1. Create the symlink to `selenium-manager` in the `envs` folder.
        See the path in the error message. This is if you're getting
        the error in the first run (after setup).
    2. I don't need "International Roaming" (for use only in India). 
        It also doesn't conform to the same design.
    3. Don't need "Talktime" (who uses it anyways? I hate calls). It 
        also breaks the validity side of scraping.
    
    Some additional notes about entries
    1. Value of "-1" in "Validity (Days)" means 'existing' (don't take
        such packs as they're add-ons)
    2. Value of "-1" in "Data Size (GB)" means 'unlimited' data
    3. Value of "Daily" for "Data Renewal" means the data quota renews
        every day (good for emergency, but usually more expensive).
        Value of "Data" means the data quota renews at the end of the
        validity period (fixed quota, don't cross it).
    
    Notes for future improvements:
    - Maybe add functions for Vodafone and Jio as well
        - https://www.myvi.in/prepaid/online-mobile-recharge
        - https://www.jio.com/selfcare/plans/mobility/jiophone-plans/
"""

# %%
import os
import sys
import time
import pandas as pd
import logging
from selenium import webdriver


# %%
web_addr = "https://www.airtel.in/recharge-online"
sheet_columns = ["Cost (INR)", "Validity (Days)", "Data Size (GB)", 
                    "Data Renewal"]


# %%
driver = webdriver.Chrome()


# %%
driver.get(web_addr)
driver.implicitly_wait(2)

# %%
from selenium.webdriver.common.by import By

# %%
elems = driver.find_elements(By.CLASS_NAME, "tabs-single-content")


# %%
# Didn't need this code generated by Bard really (LOL)
import re
def find_non_integer_or_period(text):
    """
        Finds the index of the first non-integer or period character 
        using regex.
    """
    match = re.search(r"[^\d\.]", text)  # Match any non-digit char
    return match.start() if match else -1


# %%
dfs = {
    "names": [],
    "pd": [],
}

for elem in elems:
    # Each is a separate tab
    sheet_name = elem.get_attribute("data-tab-name")
    if sheet_name == "International Roaming" or \
            sheet_name.startswith("Talktime"):
        continue
    df = pd.DataFrame(columns=sheet_columns)
    # Get all plans
    packs = elem.find_elements(By.CLASS_NAME, 
                                "pack-card-left-section")
    for i, pack in enumerate(packs):
        # Each is a plan
        details = pack.find_elements(By.CLASS_NAME, 
                                    "pack-card-detail")
        # Cost of plan
        cost = details[0].find_element(By.CLASS_NAME, # In INR
                                    "pack-card-heading").text[1:]
        df.at[i, df.columns[0]] = int(cost)
        # Validity (duration) of plan
        validity_segment = details[2].text.split("\n")
        assert validity_segment[1].lower() == "validity"
        validity = validity_segment[0].lower().split()  # Heading text
        if len(validity) == 1:
            validity = validity[0]
            assert validity == "existing"
            validity = -1   # Existing validity (over a pack)
        elif validity[1].startswith("day"):
            validity = int(validity[0])
        elif validity[1].startswith("month"):
            # 1 month = 28 days (Airtel T&C; for some reason)
            validity = int(validity[0]) * 28
        else:
            raise ValueError(f"Unknown validity: {validity}")
        df.at[i, df.columns[1]] = validity
        # Amount of data and renewal (validity) of data in plan
        data_segment = details[1].text.split("\n")
        data_size = details[1].find_element(By.CLASS_NAME, 
                                    "pack-card-heading").text
        data_renewal = details[1].find_element(By.CLASS_NAME, 
                                "pack-card-sub-heading").text
        if data_size[-2:] == "GB":
            data_size = data_size[:-2]
            if data_renewal.upper() == "/DAY":
                data_renewal = "Daily"
            elif data_renewal.upper() == "DATA":
                data_renewal = "Data"
            else:
                raise ValueError(f"Unknown: {data_renewal = }")
        else:
            data_size = -1  # Unlimited
            assert data_renewal.lower() == "unlimited"
        df.at[i, df.columns[2]] = float(data_size)
        df.at[i, df.columns[3]] = data_renewal.title()
    dfs["names"].append(sheet_name)
    dfs["pd"].append(df)

# %%
with pd.ExcelWriter("./airtel-packs.ods") as writer:
    for i, df in enumerate(dfs["pd"]):
        df.to_excel(writer, sheet_name=dfs["names"][i])

# %%
# Now analyse the packs and list them in ascending order of price
pack = "Truly Unlimited"
data_renewals = ["Daily", "Data"]
# Read the data dump
all_packs = pd.read_excel("./airtel-packs.ods", sheet_name=None)
packs = all_packs[pack]
del packs["Unnamed: 0"]
print(f"Found {len(packs)} packs for '{pack}'")

for data_renewal in data_renewals:
    packs_f = packs[packs["Data Renewal"] == data_renewal].copy()
    del packs_f["Data Renewal"]
    packs_f["Daily Cost (INR / Day)"] = packs_f["Cost (INR)"] /\
                                        packs_f["Validity (Days)"]
    # Sort by daily cost
    packs_sorted = packs_f.sort_values(by="Daily Cost (INR / Day)")

    if data_renewal == "Daily":
        print("Packs with daily data renewal")
    else:
        print("Packs with no data renewal (fixed quota)")
    print(packs_sorted)


# %%
driver.quit()

# %%
